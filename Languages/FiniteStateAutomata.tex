\documentclass{beamer}

\usepackage{wasysym}
\usepackage{tikz}
\usetikzlibrary{automata,positioning,arrows.meta}
%\usepackage[graphics,tightpage,active,pdftex]{preview}
%\setlength{\PreviewBorder}{5pt}
%\PreviewEnvironment{tikzpicture}

\usepackage[linguistics]{forest}
\usepackage[many]{tcolorbox}
\usepackage{comment}
\usepackage{multicol}
\usepackage{listings}
\usepackage{prooftree}

\newif\ifframeinlbf
\frameinlbftrue
\makeatletter
\newcommand\listofframes{\@starttoc{lbf}}
\makeatother

\addtobeamertemplate{frametitle}{}{%
    \ifframeinlbf%
         \addtocontents{lbf}{%
            \protect\makebox[2em][l]{%
                \protect\usebeamercolor[fg]{structure}\insertframenumber\hfill%
            }%
            \protect\hyperlink{page.\insertpagenumber}\insertframetitle\par%
        }%
   \else\fi%
}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\newcommand{\myalert}[2]{%
    \tikz\node[coordinate](t#1){};\alert<#1>{#2}
}


\newcommand{\myexplain}[3]
{\begin{tcolorbox}
    [   tikznode boxed title,
        enhanced,
        arc=0mm,
        interior style={white},
        attach boxed title to top center= {yshift=-\tcboxedtitleheight/2},
        fonttitle=\bfseries,
        colbacktitle=white,coltitle=red,
        boxed title style={size=small,colframe=red,boxrule=0pt},
        title={\tikz\node[coordinate](s#1) {};#2}]
#3
\end{tcolorbox}
\begin{tikzpicture}[overlay]
\path<#1>[->, thick] (s#1) edge [bend left] (t#1);
\end{tikzpicture}
}

\newcommand{\explain}[2]
{\begin{tcolorbox}
    [   tikznode boxed title,
        enhanced,
        arc=0mm,
        interior style={white},
        attach boxed title to top center= {yshift=-\tcboxedtitleheight/2},
        fonttitle=\bfseries,
        colbacktitle=white,coltitle=red,
        boxed title style={size=small,colframe=red,boxrule=0pt},
        title={#1}]
#2
\end{tcolorbox}
}

\def\point{\begin{tikzpicture}
\fill[orange] (0,0) circle (2pt);
\end{tikzpicture}}

\setbeamertemplate{navigation symbols}{} %Remove navigation bar

\tikzstyle{every picture}+=[remember picture]

\usepackage{color}
\newcommand{\vet}[1]{\foreach \num in {#1}{\el{\num}}}
\newcommand{\el}[1]{\fbox{\parbox[c][2ex][c]{1.1em}{#1}}}
\newcommand{\id}[1]{\parbox[r][2ex][b]{1.7em}{\raggedleft #1}}
\newcommand{\bl}{\color{blue}}
\newcommand{\gr}{\color{gray}}
\newcommand{\re}{\color{red}}

\title{Finite State Automata}
\author{Lunjin Lu}
\date{}


\begin{document}
\begin{comment}
\end{comment}
\frameinlbffalse
\begin{frame}[fragile,t,allowframebreaks]{List of Frames}
    \listofframes
\end{frame}
\frameinlbftrue


\frame{ \titlepage
}

\begin{frame}{Vending Machine}
The vending machine sells coffee. It accepts coins of 5\cent~ and 10\cent. It dispenses 
a can of coffee when it gets exact amount of 25 cents. 
It is stuck when the amount exceeds 25 cents.  

The machine has a number of states and two input symbols. 
Its construction is illustrated below. 

\begin{center}
\begin{tabular}{c|c|c}
state$\backslash$input       & 5\cent & 10\cent \\ \hline
q0     & q5     & q10 \\ \hline  
\end{tabular} 
\end{center} 
\end{frame}

\begin{frame}{Transition Diagram}

\end{frame} 

\begin{frame}{Language of Vending Machine} 
Which sequences of coins beget coffee? Starting at the initial state q0 and machines receives (consumes) 
coins one by one and changes its state according to the coin it gets. 
\begin{itemize}
  \item 5\cent 5\cent 10\cent 5\cent - coffee is dispensed
  \[q0 \longrightarrow^{5\cent} q5 \longrightarrow^{5\cent} q10 \longrightarrow^{10\cent} q20 \longrightarrow^{5\cent} q25  \]
  \item 5\cent 5\cent 10\cent 10\cent - machine is stuck
   \[q0 \longrightarrow^{5\cent} q5 \longrightarrow^{5\cent} q10 \longrightarrow^{10\cent} q20 \not\longrightarrow^{10\cent}  \]
\end{itemize}

\end{frame}

\begin{frame} {Stuckness and Trap States}
The vending machine is stuck on input string $\cent 5\cent 10\cent 10\cent$ 
because there is on transition from q20 labelled with 10\cent. 
A trap state  can be added so that the machine always make progress. The machine transitions to 
the trap state from a given state upon receiving a given input symbol
when it would otherwise get stuck from the state on reading the input symbol. 
The machine stays at the trap state upon reading any input symbol.  
The vending machine with an added trap state is diagramed below. 
\end{frame}

\begin{frame}{Deterministic Finite Automata}
A deterministic finite automaton is a 5-tuple $\langle Q, \Sigma, \delta, q_0, F\rangle$ where
\begin{itemize}
  \item Q is a finite set of states,
  \item $\Sigma$ is a finite set of symbols,
  \item $q_0\in Q$ ($q_0$ is called the initial state),
  \item $F\subseteq Q$ (states in F are called final states),
  \item $\delta:Q\times \Sigma\mapsto Q$ is called the transition function. 
\end{itemize}

\end{frame}

\begin{frame}{Traces/Runs}
Traces, the label of a trace, 
$p\leadsto^{w} q$ 

\end{frame}

\begin{frame}{Transition function on strings $\bar{\delta}$}

\end{frame}

\begin{frame}{Language Accepted by a DFA}

\end{frame}

\begin{frame}{Design of DFA - Example} 
Design a DFA that accepts $\{awa,bwb\mid w\in\{a,b\}^*\}$. 

\end{frame}

\begin{frame}{Design of DFA - Example}
Design a DFA that accepts $\{w\mid w\in \{0,1,2\}^*\wedge \mbox{Sum of digits in w is a multiple of 3}\}$. 

\end{frame}

\begin{frame}{Design of DFA - Example} 
Design a DFA that accepts EVEN-EVEN. 

\end{frame}


\begin{frame}{NFA}

\end{frame}

\begin{frame}{NFA Example}

\end{frame}

\begin{frame}{$\Lambda$-closure}
Inductive definition
\end{frame}

\begin{frame}{Transition function on strings $\bar{\delta}$}
$\bar{\delta}(q,w)$ is the set of states the machine 
may transition to starting at state $q$ after consuming input string $w$.
Those are the states $q'$ such that there is a trace from $q$ to $q'$ labelled with $w$. 
\[ \bar{\delta}(q,w) =\{q' \mid q\leadsto^{w} q'\}
\] 
Alternatively, \(\bar{\delta}(q,w) = \bar{\delta}(\Lambda\mbox{-closure}(\{q\}),w)\) where
\begin{eqnarray*}
\bar{\delta}(S,\Lambda) &=& S \\ 
\bar{\delta}(S,aw) &=&  \bar{\delta}(\Lambda\mbox{-closure}(\bigcup_{s\in S}\delta(s,a)),w)
\end{eqnarray*}
\end{frame}

\begin{frame}{Language Accepted by a NFA}
Let $M=$ be a NFA. 
\[L(M) = \{w \mid \exists q\in F. q_0\leadsto^{W} q\}\]
Alternatively, 

\[ L(M) = \{w \mid \bar{\delta}(q_0,w) \cap F\neq\emptyset\}\]

\end{frame}

\begin{frame}{Design of NFA}

\end{frame}

\begin{frame}{Equivalence between DFAs and NFAs}
\begin{theorem} For any NFA N, there is a DFA D such that \(L(D)=L(N)\).  
\end{theorem}
\end{frame}

\begin{frame}{Example of NFA Conversion} 
What are this NFA's possible states after consuming 0011? 

\begin{tikzpicture}[>={Stealth[width=6pt,length=9pt]}, accepting/.style={double distance = 2pt, outer sep = 1pt + \pgflinewidth}, shorten >=1pt, auto]
  \draw (30.0pt, -140.0pt)node[state, initial, initial text =](0){$q_{0}$};
  \draw (30.0pt, -55.0pt)node[state](1){$q_{1}$};
  \draw (200.0pt, -55.0pt)node[state](2){$q_{2}$};
  \draw (200.0pt, -140.0pt)node[state, accepting](3){$q_{3}$};
  \path[->] (1) edge[bend left] node{0}(2);
  \path[->] (2) edge[bend left] node{$\lambda$}(1);
  \path[->] (1) edge[loop above] node{1}(1);
  \path[->] (2) edge[loop above] node{1}(2);
  \path[->] (3) edge[loop below] node{1}(3);
  \path[->] (0) edge[loop below] node{1}(0);
  \path[->] (0) edge[bend left] node{0}(1);
  \path[->] (1) edge[bend left] node{$\lambda$}(0);
  \path[->] (2) edge[bend left] node{0}(3);
  \path[->] (3) edge[bend left] node{$\lambda$}(2);
  \path[->] (3) edge node{0}(0);
\end{tikzpicture}

\end{frame}

\begin{frame}{Example NFA}
\end{frame}

\begin{frame}{Subset Algorithm (Powerset Construction)} 
Given an NFA $N=\langle Q,\Sigma,\delta, q_i, F \rangle$,
a DFA $D=\langle Q^D, \Sigma, \delta^D,q_i^D, F^D\rangle$ is constructed as follows. 
Each state in $Q^D$ is a $\Lambda$-closed subset of $Q$. 

\begin{itemize} 
  \item Step 1: $q_i^D:=\Lambda\mbox{-closure}(\{q_i\})$; make $q_i^D$ unmarked; $Q^D:=\{q_i^D\}$; $\delta^D=\emptyset$;
  \item Step 2: Repeat the following until all states in $Q^D$ are marked.
    \begin{itemize}
      \item Pick an unmarked state $S$ from $Q^D$, 
      \item Mark $S$
      \item For each $a\in\Sigma$, 
            \begin{itemize}
              \item $S_a:=\Lambda\mbox{-closure}(\bigcup_{s\in S}\delta(s,a))$, 
              \item $\delta^D := \delta^D\cup\{S\longrightarrow^a S_a\}$;
              \item if $S_a\not\in Q^D$ then $Q^D:=Q^D\cup\{S_a\}$ and make $S_a$ unmarked;
            \end{itemize}
    \end{itemize}
  \item Step 3: $F^D=\{S\in Q^D\mid S\cap F\neq\emptyset\}$
\end{itemize}
 


\end{frame} 

\begin{frame}{Example of NFA Conversion} 

\end{frame}

\begin{frame}[allowframebreaks]{Regular Expressions to NFAs}
\begin{theorem} Given a regular expression $r$, there is an NFA $M$ such that $L(M)=L(r)$. \end{theorem}

 The proof is done by constructing $M$ from $r$ using the Thompson's algorithm. 
The algorithm constructs NFAs from regular expressions inductively.
Each constructed NFA has the following property: its initial state has no imcoming transition; 
it has a unique final state that has no outgoing transition. Let $\Sigma$ be the alphabet of $r$. 

\begin{itemize}
  \item Case $r=\emptyset$: $M=\langle \{q_i,q_f\},\Sigma,\delta,q_i,\{q_f\}\rangle$ 
  	with $\delta=\emptyset$.
  \item Case $r=\Lambda$: $M=\langle \{q_i,q_f\},\Sigma,\delta,q_i,\{q_f\}\rangle$ 
  	with $\delta = \{q_i\longrightarrow^\Lambda q_f\}$. 
  \item Case $r=a$: $M=\langle \{q_i,q_f\},\Sigma,\delta,q_i,\{q_f\}\rangle$ 
  	with $\delta = \{q_i\longrightarrow^a q_f\}$. 
  \item Case $r=r_1+r_2$. Construct recursively $M^1=\langle Q^1,\Sigma, \delta^1,q_i^1, \{q_f^1\}\rangle$ and 
         $M^2=\langle Q^2,\Sigma, \delta^2,q_i^2, \{q_f^2\}\rangle$ such that 
         $L(M^1)=L(r_1)$ and $L(M^2)=L(r_2)$ and $Q^1\cap Q^2=\emptyset$. Then 
         construct $M=\langle Q^1\cup Q^2\cup\{q_i,q_f\},\Sigma, \delta,q_i, \{q_f\}\rangle$ 
        where $q_i,q_f\not\in  Q^1\cup Q^2$
        and $\delta=\delta^1\cup\delta^2\cup\{q_i\longrightarrow^\Lambda q_i^1, q_i\longrightarrow^\Lambda q_i^2, 
        q_f^1\longrightarrow^\Lambda q_f, q_f^2\longrightarrow^\Lambda q_f\}$. 
     \item Case $r=r_1\cdot r_2$. Construct recursively $M^1=\langle Q^1,\Sigma, \delta^1,q_i^1, \{q_f^1\}\rangle$ and 
         $M_2=\langle Q^2,\Sigma, \delta^2,q_i^2, \{q_f^2\}\rangle$ such that 
         $L(M^1)=L(r_1)$ and $L(M^2)=L(r_2)$ and $Q^1\cap Q^2=\emptyset$. 
        Then construct $M=\langle Q^1\cup Q^2\cup\{q_i,q_f\},\Sigma, \delta,q_i, \{q_f\}\rangle$ 
        where $q_i,q_f\not\in  Q^1\cup q^2$
        and $\delta=\delta^1\cup\delta^2\cup\{q_i\longrightarrow^\Lambda q_i^1,  
        q_f^1 \longrightarrow^\Lambda q_i^2, q_f^2\longrightarrow^\Lambda q_f\}$.  
     \item Case $r=(r_1)$. Construct recursively $M^1$ such that $L(M^1)=L(r_1)$ and then put $M=M^1$.
     \item Case $r=r_1^*$.  Construct recursively $M^1=\langle Q^1,\Sigma, \delta^1,q_i^1, \{q_f^1\}\rangle$ and 
         such that 
         $L(M^1)=L(r_1)$. Then 
         construct $M=\langle Q^1\cup\{q_i,q_f\},\Sigma, \delta,q_i, \{q_f\}\rangle$ 
        where $q_i,q_f\not\in  Q^1$
        and $\delta=\delta^1\cup\{ q_f^1 \longrightarrow^\Lambda q_i^1, 
        q_i\longrightarrow^\Lambda q_i^1,  
        q_f^1\longrightarrow^\Lambda q_f, q_i \longrightarrow^\Lambda q_f\}$.    
\end{itemize}




\end{frame}



\begin{frame}[allowframebreaks]{NFAs to Regular Expressions}
\begin{theorem}
Given an NFA M, there is a regular expression r such that $L(r)=L(M)$. 
\end{theorem}

The proof uses the notion of a Generalized Transition Graph (aka Generalized NFA). 
A transition from one state to another in a GTG is labelled with a regular expression. 
The GTG transitions from the source state to the target upon reading a string in 
the langauge of the regular expression. Every NFA is a GTG. 

Given a GTG M, the algorithm works as follows.


\begin{itemize}
  \item Step 1: Add a new state $q_i$ to $M$ and add a $\Lambda$ transition from $q_i$ to the initial state of $M$. 
                Make $q_i$ the new initial state and the orginal initial state of $M$ non-initial. 
                Note that $q_i$ has no incoming transition. This property is maintained throughout the process. 
  \item Step 2: Add a new state $q_f$ to $M$ and add a $\Lambda$ transition from each final state of $M$ to $q_f$. 
  				Make $q_f$ the new final state and the orginal final states of $M$ non-final. 
  				Note that $q_f$ has no outgoing transition. This property is maintained throughout the process.
  \item Step 3: For each pair of states $p$ and $q$, if there are multiple transitions from $p$ to $q$ 
  				then merge them into one. 
  				Let all the transitions from $p$ to $q$ be $p\longrightarrow^{r_1} q, p\longrightarrow^{r_2} q, 
  					\cdots,  p\longrightarrow^{r_k} q$. 
                The merged transition is $p\longrightarrow^{r_1+r_2\cdots r_k} q$.
                
                After this step, there is at most one transition from $p$ to $q$ for all states $p$ and $q$. 
   \item Step 4: Repeatedly eliminate a state from $M$ until $M$ has no other states than $q_i$ and $q_f$ as follows.
   			\begin{itemize} 
   			  \item Pick a state $s$ that is not $q_i$ or $q_f$. 
   			  		If there is a loop from $s$ to $s$,
   			  		let $R$ be the label of the transition. Otherwise, $R=\Lambda$. 
   			  \item For each state $p$ such that there is a transition 
   			  		$p\longrightarrow^P s$ and each state $q$ such that there is a transition $s\longrightarrow^ Q q$,
   			  		\begin{itemize} 
   			  		  \item Add a new transiton $p\longrightarrow^{PR^*Q} q$ to $M$
   			  		  \item If there was a transition from $p$ to $q$ before the new transiton was added, 
   			  		  merge it with the new one. This ensure that there is at most one transition from $p$ to $q$. 
					\end{itemize}
   			   \item Remove the state $s$ and its incoming and outgoing transitions.
   			\end{itemize}    
   	\item Step 5: If $q_i\longrightarrow^R q_f$ then return $R$ else return $\emptyset$. 
\end{itemize}

\end{frame}

\begin{frame}{Moore Machines} 
A Moore machine is a deterministic finite automaton with output. 
Each state emits an output symbol (or nothing) whenever it is entered. 
A Moore machine is deterministic and it has no $\Lambda$ transitions. 
It has no final states as it is a transducer. 
\end{frame}

\begin{frame}{Example Moore Machine}
\begin{center}
\resizebox{.7\textwidth}{!}{
\begin{tikzpicture}[>={Stealth[width=6pt,length=9pt]}, accepting/.style={double distance = 2pt, outer sep = 1pt + \pgflinewidth}, shorten >=1pt, auto]
  \draw (100.0pt, -120.0pt)node[state, initial, initial text =](0){$q_{0}/0$};
  \draw (250.0pt, -50.0pt)node[state](1){$q_{1}/1$};
  \draw (400.0pt, -120.0pt)node[state](2){$q_{2}/2$};
  \path[->] (0) edge[loop above] node{0}(0);
  \path[->] (1) edge[loop above] node{0}(1);
  \path[->] (2) edge[loop above] node{0}(2);
  \path[->] (0) edge node{1}(1);
  \path[->] (2) edge node{1}(0);
  \path[->] (1) edge node{1}(2);
\end{tikzpicture}
}
\end{center}
\end{frame}

\begin{frame}{Moore Machine}
A Moore is a 5-tuple $\langle Q, \Sigma, \Gamma, q_0, \delta,\rho$ where
\begin{itemize}
  \item Q is a finite set of states,
  \item $\Sigma$ is a finite set of input symbols,
  \item $\Gamma$ is a finite set of output symbols,
  \item $q_0\in Q$ is  the initial state,
  \item $\delta:Q\times \Sigma\mapsto Q$ is  the transition function,
  \item $\rho: Q \mapsto\Gamma\cup\{\Lambda\}$ is the output function. 
\end{itemize}
Note that $\delta$ is a total function,
meaning that behavior of the machine is defined
for all possible input strings. 
\end{frame}

\begin{frame}{Meely Machines}
A Meely machine outputs a symbol (or nothing) when it transitions from one state to another. 
It is a deterministic in that its transition function maps 
a pair consisting of a state and an input symbol to a pair consisting of a state and an output symbol (or nothing).  
\end{frame}

\begin{frame}{Example Meely Machine}
\begin{center}
\resizebox{.7\textwidth}{!}{%
\begin{tikzpicture}[>={Stealth[width=6pt,length=9pt]}, accepting/.style={double distance = 2pt, outer sep = 1pt + \pgflinewidth}, shorten >=1pt, auto]
  \draw (100.0pt, -120.0pt)node[state, initial, initial text =](0){$q_{0}$};
  \draw (250.0pt, -50.0pt)node[state](1){$q_{1}$};
  \draw (400.0pt, -120.0pt)node[state](2){$q_{2}$};
  \path[->] (0) edge[loop above] node{0}(0);
  \path[->] (1) edge[loop above] node{0}(1);
  \path[->] (2) edge[loop above] node{0}(2);
  \path[->] (0) edge node{1/1}(1);
  \path[->] (1) edge node{1/2}(2);
  \path[->] (2) edge node{1/0}(0);
\end{tikzpicture}
}%
\end{center}
\end{frame}


\begin{frame}{Meely Machine}
A Moore is a 5-tuple $\langle Q, \Sigma, \Gamma, q_0, \delta, \rho$ where
\begin{itemize}
  \item Q is a finite set of states,
  \item $\Sigma$ is a finite set of input symbols,
  \item $\Gamma$ is a finite set of output symbols,
  \item $q_0\in Q$ is  the initial state,
  \item $\delta:Q\times \Sigma\mapsto Q$ is the transition function, and 
  \item $\rho:Q\times\Sigma\mapsto (\Gamma\cup\{\Lambda\})$ is  the output function.
\end{itemize}
Note that $\delta$ is a total function,
meaning that behavior of the machine is defined
for all possible input strings. 
\end{frame}

\begin{frame}{Meely = Moore}
Moore and Meely machines are equivalent barring the first output symbol of the Moore machine. 
\end{frame}

\begin{frame}{From Moore machines to Meely machines} 
Push the output symbol associated with a state to all incoming transitions of the state.  

\end{frame}


\begin{frame}{From Meely Machines to Moore machines}
Push the output symbol associated with a transiton into the target state 
and split the target state into multiple states 
- one for each output symbol pushed into it. 

\end{frame}

\end{document}